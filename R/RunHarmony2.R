#' @title Run Harmony algorithm
#'
#' @description
#' This is a modified version of [harmony::RunHarmony] specifically designed for compatibility with RunSymphonyMap.
#'
#' @md
#' @inheritParams thisutils::log_message
#' @param object A Seurat object.
#' @param group.by.vars The batch variable name.
#' @param reduction The reduction to be used.
#' Default is `"pca"`.
#' @param dims.use The dimensions to be used.
#' Default is `1:30`.
#' @param reduction.name The name of the reduction to be stored in the Seurat object.
#' Default is `"Harmony"`.
#' @param reduction.key The prefix for the column names of the Harmony embeddings.
#' Default is `"Harmony_"`.
#' @param project.dim Whether to project dimension reduction loadings.
#' Default is `TRUE`.
#' @param seed.use The random seed to be used.
#' Default is `11`.
#' @param ... Additional arguments to be passed to [harmony::RunHarmony].
#'
#' @rdname RunHarmony2
#' @export
#'
#' @examples
#' panc8_sub <- RunHarmony2(
#'   panc8_sub,
#'   group.by.vars = "tech",
#'   reduction = "pca"
#' )
#' CellDimPlot(
#'   panc8_sub,
#'   group.by = c("tech", "celltype"),
#'   reduction = "pca"
#' )
#' CellDimPlot(
#'   panc8_sub,
#'   group.by = c("tech", "celltype"),
#'   reduction = "Harmony"
#' )
RunHarmony2 <- function(object, ...) {
  UseMethod(generic = "RunHarmony2", object = object)
}

#' @rdname RunHarmony2
#' @method RunHarmony2 Seurat
#' @export
RunHarmony2.Seurat <- function(
    object,
    group.by.vars,
    reduction = "pca",
    dims.use = 1:30,
    project.dim = TRUE,
    reduction.name = "Harmony",
    reduction.key = "Harmony_",
    verbose = TRUE,
    seed.use = 11L,
    ...) {
  check_r("harmony@1.1.0")
  if (!is.null(x = seed.use)) {
    set.seed(seed = seed.use)
  }
  if (length(dims.use) == 1) {
    log_message(
      "only specified one dimension in dims.use",
      message_type = "error"
    )
  }

  data.use <- Seurat::Embeddings(object[[reduction]])
  if (max(dims.use) > ncol(data.use)) {
    log_message(
      "trying to use more dimensions than computed",
      message_type = "error"
    )
  }

  assay <- SeuratObject::DefaultAssay(object = object[[reduction]])
  metavars_df <- Seurat::FetchData(
    object,
    group.by.vars,
    cells = rownames(data.use)
  )

  harmonyObject <- harmony::RunHarmony(
    data_mat = data.use[, dims.use, drop = FALSE],
    meta_data = metavars_df,
    vars_use = group.by.vars,
    verbose = verbose,
    return_object = TRUE,
    ...
  )

  harmonyEmbed <- Matrix::t(as_matrix(harmonyObject$Z_corr))
  rownames(harmonyEmbed) <- row.names(data.use)
  colnames(harmonyEmbed) <- paste0(
    reduction.name,
    "_",
    seq_len(ncol(harmonyEmbed))
  )

  harmonyClusters <- Matrix::t(harmonyObject$R)
  rownames(harmonyClusters) <- row.names(data.use)
  colnames(harmonyClusters) <- paste0("R", seq_len(ncol(harmonyClusters)))

  object[[reduction.name]] <- Seurat::CreateDimReducObject(
    embeddings = harmonyEmbed,
    stdev = as.numeric(apply(harmonyEmbed, 2, stats::sd)),
    assay = assay,
    key = reduction.key,
    misc = list(
      R = harmonyClusters,
      reduction_use = reduction,
      reduction_dims = dims.use
    )
  )

  if (project.dim) {
    object <- Seurat::ProjectDim(
      object,
      reduction = reduction.name,
      overwrite = TRUE,
      verbose = FALSE
    )
  }
  object <- Seurat::LogSeuratCommand(object = object)
  return(object)
}
