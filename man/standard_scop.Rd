% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/standard_scop.R
\name{standard_scop}
\alias{standard_scop}
\title{Standard workflow for scop}
\usage{
standard_scop(
  srt,
  prefix = "Standard",
  assay = NULL,
  do_normalization = NULL,
  normalization_method = "LogNormalize",
  do_HVF_finding = TRUE,
  HVF_method = "vst",
  nHVF = 2000,
  HVF = NULL,
  do_scaling = TRUE,
  vars_to_regress = NULL,
  regression_model = "linear",
  linear_reduction = "pca",
  linear_reduction_dims = 50,
  linear_reduction_dims_use = NULL,
  linear_reduction_params = list(),
  force_linear_reduction = FALSE,
  nonlinear_reduction = "umap",
  nonlinear_reduction_dims = c(2, 3),
  nonlinear_reduction_params = list(),
  force_nonlinear_reduction = TRUE,
  neighbor_metric = "euclidean",
  neighbor_k = 20L,
  cluster_algorithm = "louvain",
  cluster_resolution = 0.6,
  verbose = TRUE,
  seed = 11
)
}
\arguments{
\item{srt}{A Seurat object.}

\item{prefix}{A prefix to add to the names of intermediate objects created by the function.
Default is \code{"Standard"}.}

\item{assay}{The name of the assay to use for the analysis.
If \code{NULL}, the default assay of the Seurat object will be used.}

\item{do_normalization}{Whether to perform normalization.
If \code{NULL}, normalization will be performed if the specified assay does not have scaled data.}

\item{normalization_method}{The method to use for normalization.
Options are \code{"LogNormalize"}, \code{"SCT"}, or \code{"TFIDF"}.
Default is \code{"LogNormalize"}.}

\item{do_HVF_finding}{Whether to perform high variable feature finding.
If \code{TRUE}, the function will force to find the highly variable features (HVF) using the specified HVF method.}

\item{HVF_method}{The method to use for finding highly variable features.
Options are \code{"vst"}, \code{"mvp"}, or \code{"disp"}.
Default is \code{"vst"}.}

\item{nHVF}{The number of highly variable features to select.
If NULL, all highly variable features will be used.}

\item{HVF}{A vector of feature names to use as highly variable features.
If NULL, the function will use the highly variable features identified by the HVF method.}

\item{do_scaling}{Whether to perform scaling.
If \code{TRUE}, the function will force to scale the data using the \link[Seurat:ScaleData]{Seurat::ScaleData} function.}

\item{vars_to_regress}{A vector of feature names to use as regressors in the scaling step.
If NULL, no regressors will be used.}

\item{regression_model}{The regression model to use for scaling.
Options are \code{"linear"}, \code{"poisson"}, or \code{"negativebinomial"}.
Default is \code{"linear"}.}

\item{linear_reduction}{The linear dimensionality reduction method to use.
Options are \code{"pca"}, \code{"svd"}, \code{"ica"}, \code{"nmf"}, \code{"mds"}, or \code{"glmpca"}.
Default is \code{"pca"}.}

\item{linear_reduction_dims}{The number of dimensions to keep after linear dimensionality reduction.
Default is \code{50}.}

\item{linear_reduction_dims_use}{The dimensions to use for downstream analysis.
If \code{NULL}, all dimensions will be used.}

\item{linear_reduction_params}{A list of parameters to pass to the linear dimensionality reduction method.}

\item{force_linear_reduction}{Whether to force linear dimensionality reduction even if the specified reduction is already present in the Seurat object.}

\item{nonlinear_reduction}{The nonlinear dimensionality reduction method to use.
Options are \code{"umap"}, \code{"umap-naive"}, \code{"tsne"}, \code{"dm"},
\code{"phate"}, \code{"pacmap"}, \code{"trimap"}, \code{"largevis"}, or \code{"fr"}.
Default is \code{"umap"}.}

\item{nonlinear_reduction_dims}{The number of dimensions to keep after nonlinear dimensionality reduction.
If a vector is provided, different numbers of dimensions can be specified for each method.
Default is \code{c(2, 3)}.}

\item{nonlinear_reduction_params}{A list of parameters to pass to the nonlinear dimensionality reduction method.}

\item{force_nonlinear_reduction}{Whether to force nonlinear dimensionality reduction even if the specified reduction is already present in the Seurat object.
Default is \code{TRUE}.}

\item{neighbor_metric}{The distance metric to use for finding neighbors.
Options are \code{"euclidean"}, \code{"cosine"}, \code{"manhattan"}, or \code{"hamming"}.
Default is \code{"euclidean"}.}

\item{neighbor_k}{The number of nearest neighbors to use for finding neighbors.
Default is \code{20}.}

\item{cluster_algorithm}{The clustering algorithm to use.
Options are \code{"louvain"}, \code{"slm"}, or \code{"leiden"}.
Default is \code{"louvain"}.}

\item{cluster_resolution}{The resolution parameter to use for clustering.
Larger values result in fewer clusters.
Default is \code{0.6}.}

\item{verbose}{Whether to print the message.
Default is \code{TRUE}.}

\item{seed}{The random seed to use for reproducibility.
Default is \code{11}.}
}
\value{
A \code{Seurat} object.
}
\description{
This function performs a standard single-cell analysis workflow.
}
\examples{
library(Matrix)
PrepareEnv()
data(pancreas_sub)
pancreas_sub <- standard_scop(pancreas_sub)
CellDimPlot(
  pancreas_sub,
  group.by = "SubCellType"
)

# Use a combination of different linear
# or non-linear dimension reduction methods
linear_reductions <- c(
  "pca", "nmf", "mds", "glmpca"
)
pancreas_sub <- standard_scop(
  pancreas_sub,
  linear_reduction = linear_reductions,
  nonlinear_reduction = "umap"
)
plist1 <- lapply(
  linear_reductions, function(lr) {
    CellDimPlot(
      pancreas_sub,
      group.by = "SubCellType",
      reduction = paste0(
        "Standard", lr, "UMAP2D"
      ),
      xlab = "", ylab = "", title = lr,
      legend.position = "none",
      theme_use = "theme_blank"
    )
  }
)
patchwork::wrap_plots(plotlist = plist1)

nonlinear_reductions <- c(
  "umap", "tsne", "dm", "phate",
  "pacmap", "trimap", "largevis", "fr"
)
pancreas_sub <- standard_scop(
  pancreas_sub,
  linear_reduction = "pca",
  nonlinear_reduction = nonlinear_reductions
)
plist2 <- lapply(
  nonlinear_reductions, function(nr) {
    CellDimPlot(
      pancreas_sub,
      group.by = "SubCellType",
      reduction = paste0(
        "Standardpca", toupper(nr), "2D"
      ),
      xlab = "", ylab = "", title = nr,
      legend.position = "none",
      theme_use = "theme_blank"
    )
  }
)
patchwork::wrap_plots(plotlist = plist2)
}
\seealso{
\link{integration_scop}
}
